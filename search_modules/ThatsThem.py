import tls_client
from bs4 import BeautifulSoup
from typing import Optional, Dict, List
import time
import requests

class SearchAPIProcessor:
    name = "ThatsThem (ReCaptchaV2)"
    developer = "@CPUCycle"

    @staticmethod
    def required_settings() -> List[str]:
        return ['capsolver_key']

    async def search(self, email: str, settings: Dict[str, str], proxy: str) -> Optional[Dict]:
        print(f"Processing {email} with ThatsThem")
        self.proxy = proxy
        self.capsolver_key = settings.get('capsolver_key')

        if not self.capsolver_key:
            raise ValueError("Capsolver key not found in settings")

        try:
            session = tls_client.Session(
                client_identifier="chrome112",
                random_tls_extension_order=True
            )
            session.proxies = {'http': self.proxy, 'https': self.proxy}
            session.timeout_seconds = 30
            headers = {
                'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                'accept-language': 'en-US,en;q=0.9',
                'sec-ch-ua': '"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"Windows"',
                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
            }

            params = {'sort': 'scores.Wealth', 'order': 'desc'}

            response = session.get(f'https://thatsthem.com/email/{email}', params=params, headers=headers, allow_redirects=True)

            if "/challenge" in response.url or '/register' in response.url:
                solution = self.get_captcha_solution()
                response = session.post(
                    "https://thatsthem.com/challenge",
                    data={
                        "g-recaptcha-response": solution,
                        "r": f"/email/{email}?sort=scores.Wealth&order=desc"
                    },
                    headers=headers,
                    allow_redirects=True
                )

            if 'Generated by cloudfront (CloudFront)' in response.text:
                raise Exception("Cloudfront Blocked")

            soup = BeautifulSoup(response.content, 'html.parser')
            first_card = soup.select_one('div.record div.card')

            if not first_card:
                return None

            def safe_extract(element, method='get_text', **kwargs):
                return getattr(element, method)(**kwargs).strip() if element and method else None

            name = safe_extract(first_card.find('div', class_='name'))

            age_element = first_card.find('div', class_='age')
            age = safe_extract(age_element)
            if age:
                age = age.split('(')[-1].replace('years old)', '').strip().replace('Age ', '')

            try:
                street = safe_extract(soup.find('span', class_='street'))
                city = safe_extract(soup.find('span', class_='city'))
                state = safe_extract(soup.find('span', class_='state'))
                zip_code = safe_extract(soup.find('span', class_='zip')).split('+')[0]
                formatted_address = f"{street}, {city}, {state} {zip_code}" if all([street, city, state, zip_code]) else None
            except:
                formatted_address = None

            phone_elements = first_card.find_all('span', class_='number')
            phone_numbers = [safe_extract(phone).replace("-", "") for phone in phone_elements] if phone_elements else []

            return {
                'email': email,
                'name': name or None,
                'phone_numbers': phone_numbers,
                'address': formatted_address,
                'dob': age or None,
            }

        except Exception as e:
            print(f"Error processing {email}: {e}")
            return None

    def supports_email(self, email: str) -> bool:
        return True

    def get_captcha_solution(self):
        while True:
            try:
                payload = {
                    "clientKey": self.capsolver_key,
                    "task": {
                        "type": "ReCaptchaV2TaskProxyLess",
                        "websiteURL": "https://thatsthem.com",
                        "websiteKey": '6Ldx4RATAAAAAKBXQ1OdnsaVrzgfTfatWNH84j-n'
                    }
                }

                response = requests.post("http://api.capsolver.com/createTask", json=payload)
                task_id = response.json().get("taskId")

                while True:
                    task_result_payload = {"clientKey": self.capsolver_key, "taskId": task_id}
                    result_response = requests.post("http://api.capsolver.com/getTaskResult", json=task_result_payload)

                    if result_response.status_code == 403:
                        print("Received a 403 error. Check your API key, task ID, or possible IP blocking.")
                        raise Exception

                    if "ERROR_" in result_response.text:
                        print(f"Error from Capsolver: {result_response.text}")
                        raise Exception

                    if result_response.json().get("status") == "ready":
                        return result_response.json().get("solution", {}).get("gRecaptchaResponse")

                    time.sleep(1)
            except Exception as e:
                print(f"Captcha solving error: {e}")
